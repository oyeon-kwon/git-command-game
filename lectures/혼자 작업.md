## Fork
![image](https://user-images.githubusercontent.com/61301574/111421616-a3ba2f00-8730-11eb-977f-a268ed68705a.png)

 Git으로 관리되고 있는 git-project 라는 프로젝트가 있습니다. 김코딩은 이 레파지토리에 contribute를 하고 싶어요.
 먼저 내 계정으로 해당 레파지토리를 가지고 오려고 합니다.
 이 때 사용할 수 있는 기능이 Fork 입니다. 포크로 집어 온다는 의미라고 생각하시면 됩니다. 우측 상단의 Fork 버튼을 클릭해볼까요?

![](https://user-images.githubusercontent.com/61301574/110565498-f2e0ec80-8191-11eb-86b4-8e9755b4a0db.jpeg)

 우측 상단의 Fork 버튼을 누르면 다음 화면이 뜨는 것을 확인하실 수 있습니다. 나의 유저네임을 클릭하면 Fork 작업이 완료됩니다.


![](https://user-images.githubusercontent.com/61301574/110565500-f4121980-8191-11eb-9135-de025c1e77bd.jpeg)


리모트 레파지토리(원격 저장소)란?
GitHub.com 의 내 계정에 Fork해서 들어온 kimcoding / git-project는 나의 리모트 레파지토리 (원격 저장소) 입니다.

 Fork 가 완료된 상태는 내 리모트 레파지토리에 해당 레파지토리가 들어 있는 상태입니다. 이제 리모트에 있는 레파지토리를 내 로컬 컴퓨터 환경에서 작업할 수 있도록 명령어를 입력해 보겠습니다.


## clone
![](https://user-images.githubusercontent.com/61301574/110565564-07bd8000-8192-11eb-96ab-df9d57647065.jpeg)

 이제 리모트 레파지토리에 있는 내용을 작업하기 위해서는 내 컴퓨터의 로컬 환경으로 복사해오는 작업이 필요합니다. 이 때 사용할 수 있는 명령어가 바로 clone 입니다. git clone 명령어 뒤에 레파지토리 주소를 입력하면 해당 레파지토리를 로컬로 가져와서 작업할 수 있습니다.
```
터미널 화면
Cloning into ‘git-project… \n remote: Enumerating objects: 3, done. \n remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3 Unpacking objects: 100% (3/3), done.
```

## status

![](https://user-images.githubusercontent.com/61301574/110565605-160b9c00-8192-11eb-9974-8cb87a579670.jpeg)


 git-project를 포크해서 마이페이지 기능을 만들었어요. commit 으로 변경 사항의 저장 기록을 남겨두는 것이 좋을 것 같아요. Commit 을 하기 위해서 먼저 현재 로컬에 변경된 파일들이 어떤 것이 있는지 확인해보려고 합니다. 
git status 명령어를 통해 staging area와 untracked files 목록에 어떤 것들이 있는지 확인할 수 있습니다.

Untracked files 영역은 로컬에는 존재하지만 Git 의 관리 하에 아직 들어가지 않은 영역입니다. 이 영역에 있는 파일은 commit 될 수 없습니다.

```
터미널 화면
On branch main. \n Untracked files: \n (use 'git add <file>...' to include in what will be committed) \n mypage.js \n nothing added to commit but untracked files present (use 'git add' to track)
```

## restore

내가 만든 마이페이지를 커밋을 하기 전에 기존 레파지토리 코드를 훑어보니 function 컴포넌트로만 작성이 되어 있네요. 나는 class 컴포넌트로 작성을 했는데 통일성을 해칠 것 같아요. 내가 작업한 코드를 싹 다 밀어버리고 새로 작업 해야할 것 같습니다. 그러니까 최근 커밋된 버전으로(아니면 처음 Clone 했을 때처럼 워킹 디렉토리에 처음 Checkout 한 그 내용으로) 되돌리는 방법이 있을까요? 이 때 사용할 수 있는 명령어가 restore (커밋되지 않은 로컬 변경사항을 unstaging 하거나 discard 하는 명령어) 입니다. git restore mypage.js 명령어를 통해 Working directory의 변경사항을 폐기하고 처음으로 clone 받아왔던 상태가 되었습니다. 
```
터미널 화면
Changes not staged for commit: (use "git add ..." to update what will be committed) (use "git checkout -- ..." to discard changes in working directory)
modified:   mypage.js
위의 메시지는 수정한 파일을 되돌리는 방법을 꽤 정확하게 알려준다. 알려주는 대로 한 번 해보자.
$ git checkout -- mypage.js $ git status On branch master Changes to be committed: (use "git reset HEAD ..." to unstage)
renamed:    mypage.js -> mypage.js
```
정상적으로 복원된 것을 알 수 있다.


## Add

![](https://user-images.githubusercontent.com/61301574/110565637-1f950400-8192-11eb-9f1e-06c6dbf88349.jpeg)

![](https://user-images.githubusercontent.com/61301574/110565702-389db500-8192-11eb-9acd-9f2000e57d73.jpeg)


그렇다면 commit 을 하기 위해서는 Git의 관리 하에 있는 영역으로 파일들을 옮겨주어야 하는데요. 이 영역의 이름은 바로 staging area 입니다. Untracked files 영역에서 staging area 로 파일들을 추가하는 명령어는 git add <파일이름> 입니다. 여기서는 git add mypage.js 를 입력하면 되겠네요. 
* 파일이 너무 많은데 이 파일들을 하나하나 다 적어야 하나요? 
-> git add . : staging area의 모든 파일들을 한번에 추가하고 싶다면 git add . 명령어를 사용할 수 있습니다.
-> git add * : 현재 디렉토리의 모든 파일을 추가하고 싶다면 git add * 명령어를 사용할 수 있습니다.


Commit

![](https://user-images.githubusercontent.com/61301574/110565702-389db500-8192-11eb-9acd-9f2000e57d73.jpeg)

￼
![image](https://user-images.githubusercontent.com/61301574/111421648-b2084b00-8730-11eb-9682-0376c307342b.png)

 변경 사항을 저장하기 위해서는 commit 을 활용합니다. 어떤 사항이 변경되었는지 간단한 메모를 통해서 버전의 변경 기록들을 관리할 수 있습니다. 위 그림처럼 스냅샷을 찍듯이 변경된 이력을 언제, 누가, 어떻게 변경이 되었는지 저장할 수 있어요.
 이제 mypage.js 파일이 staging area에 올라간 상태이기 때문에 commit이 가능한 파일이 되었어요. commit 메시지를 작성하기 위해서는 -m 옵션을 통해 코멘트를 작성할 수 있습니다. git commit -m ’Add mypage’ 라는 메시지로 commit 을 남겨볼까요?
 참고로 commit 메시지 작성 방법에 대해서는 굉장히 다양한 기준과 컨벤션이 있기 때문에 좋은 commit 메시지를 작성하기 위한 기준을 구글링해 보시는 것을 추천합니다.
```
터미널 화면
[main 2a4535f] completed 1 files changed, \n 123 insertions(+) create mode 100644 mypage.js
```

### Staging area 란?
커밋하기 전에 내용을 기록하는 장소

만약, Git add 명령어로 파일을 staging area에 올려놓고 파일을 또 수정한다면?

```￼
 $ git status On branch master Your branch is up-to-date with 'origin/master'. Changes to be committed: (use "git reset HEAD ..." to unstage)
new file:   README
modified:   mypage.js
Changes not staged for commit: (use "git add ..." to update what will be committed) (use "git checkout -- ..." to discard changes in working directory)
modified:   mypage.js
```
이렇게 파일이 staged 이면서 modified 인 상태가 됩니다. 
즉 git add 명령을 실행하면 Git은 파일을 바로 Staged 상태로 만듭니다. 지금 이 시점에서 커밋을 하면 git commit 명령을 실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 git add 명령을 실행했을 때의 버전이 커밋되지요. 그러니까 git add 명령을 실행한 후에 또 파일을 수정하면 git add 명령을 다시 실행해서 최신 버전을 Staged 상태로 만들어야 합니다.

+++ 요 내용 추가하는 것은 어떤가요?
이사를 가기 위해서 박스를 싸야할 때, 박스가 staging area이고 박스에 물건을 넣어 라벨링을 하는 것을 commit 이라 비유할 수 있습니다.
￼
![image](https://user-images.githubusercontent.com/61301574/111421674-bcc2e000-8730-11eb-934f-3e93f8a95433.png)

(출처: https://coderefinery.github.io/git-intro/04-staging-area/)


## Reset

![](https://user-images.githubusercontent.com/61301574/110565718-3e939600-8192-11eb-81ba-1a0f03cb787e.jpeg)
앗.. 그런데 에러가 하나 발생했네요ㅠㅠ
방금 커밋한 기록을 취소할 수는 없을까요?
아직 리모트 레파지토리에 업로드 되지 않고 로컬에만 commit 해 놓은 기록이라면 reset 명령어를 통해서 commit 을 취소할 수 있습니다. git reset HEAD^ 이라는 명령어로 가장 최신의 commit 을 취소할 수 있습니다.
 우리는 방금 올린 하나의 commit 만 취소하면 되기 때문에 git reset HEAD^ 명령어를 입력하는 것이 가장 적합하겠죠?
 HEAD~는 연속된 ^의 shortcut 입니다. 예를 들어 HEAD~3은 HEAD^^^와 같습니다. 즉 이 상황에서는 HEAD~1 명령어도 가능합니다.

(출처: https://salferrarello.com/git-head-tilde-vs-head-caret/)

 추가적으로 hard, soft 옵션이 있기 때문에 reset 에 대해서 더 공부하고 싶으시다면 git reset --hard vs --soft 등의 검색어로 구글링 한 후 실습해 보시는 것을 추천드립니다.

```
Unstaged changes after reset: \n M   mypage.js
```

## Push

![](https://user-images.githubusercontent.com/61301574/110565752-4eab7580-8192-11eb-93c0-0a169ed2d41b.jpeg)

 commit 기록을 남기기를 완료했어요. 이제 이 파일들을 contribute 하기 위해서는 Pull Request 라는 것을 날려주어야 한다고 하는데요. Pull Request를 날리기 위해서는 현재 로컬에 저장되어 있는 commit 기록들을 내 리모트 레파지토리에 업로드해 주어야 과제를 제출하는 Pull Request 를 날릴 수가 있습니다.
 내 로컬의 commit 기록들을 리모트 리파지토리로 업로드하기 위해서는 git push origin branch 명령어를 사용할 수 있습니다. git push origin main, git push pair dev 등 git push 뒤에 따라오는 명령어는 상황에 따라 변경할 수 있습니다.

Push를 했더니 GitHub 웹사이트의 레파지토리에 compare & pull request 라는 버튼이 뜨네요.

![](https://user-images.githubusercontent.com/61301574/110565788-61be4580-8192-11eb-9986-85bb1b469d11.png)
![](https://user-images.githubusercontent.com/61301574/110565801-6682f980-8192-11eb-8255-32a2aaf37040.png)
요 버튼을 클릭해서 과제를 완료했다는 Pull Request 날리기를 완료했습니다!


```
Enumerating objects: 1, done. \n Counting objects: 100% (1/1), done. \n Delta compression using up to 1 threads. \n Compressing objects: 100% (1/1), done. \n Writing objects: 100% (1/1), 212.65 KiB | 10.63 MiB/s, done. \n Total 1 (delta 0), reused 0 (delta 0). To https://github.com/codestates/git-project 9ec18c7..6b4395c  main -> main
```

## Log

![](https://user-images.githubusercontent.com/61301574/110565763-5408c000-8192-11eb-839e-31f35a230ff2.jpeg)


남긴 커밋이 잘 기록되었는지 확인해보고 싶어요. git log 라는 명령어를 터미널에 입력해볼까요? 현재까지 commit 된 로그들을 터미널 창에서 확인할 수 있습니다.
```
commit 6b4395cec5934268a2bb5e41cd81a488891f02fb (HEAD -> main, origin/main, origin/HEAD) \n Author: kimcoding <kimcoding@gmail.com> \n Date:   Tue Feb 16 13:13:56 2021 +0900 \n\n Add mypage
```
