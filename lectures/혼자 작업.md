# slide_1) git의 버전 관리 기능 활용하기 (혼자 작업)

# script_1)
이번 강의에서는 git의 버전 관리 기능을 어떻게 활용할 수 있을지 알아봅시다.
Git으로 관리하며 누구나 contribute 할 수 있게 허용해 놓은 오픈 소스 프로젝트가 있다면 내가 어떻게 contribute를 할 수 있을까요?

# slide_2) github overview

# script_2)
이번 시간에 배우게 될 전체적인 흐름은 다음 그림과 같습니다. Remote에 있는 다른 Repository에서 Fork를 해서 Remote에 있는 내 Repository에 가지고 옵니다. 그리고 내 컴퓨터에서 작업을 하기 위해서는 clone을 해 와야 해요. 이제 내 컴퓨터의 work space 에서 작업에 들어간 파일들은 기본적인 초안 작업이 끝나면 git의 관리 하에 있는 상태로 올려줄 수 있습니다. 이 영역을 staging area라고 말합니다. 즉, staging area에 들어오지 않은 파일은 unstaged 혹은 untracked file이라고 말하며, staging area에 있는 파일들은 staged 된 파일이라고 말할 수 있어요. 이 부분에 대해서는 나중에 더 자세하게 알아봅시다. staging area에 들어온 파일들은 commit 이 가능합니다. commit을 하고 나면 내 remote repository에 push 해서 commit 기록을 remote 에도 남겨줄 수 있고요. push가 완료되었다면 이제 remote의 원래 레파지토리에 pull request를 보내면 Remote Repository로 내가 수정한 코드를 업로드할 수 있어요. 

# slide_3) fork: 다른 계정의 Remote Repository를 내 계정으로 가지고 올 때
![image](https://user-images.githubusercontent.com/61301574/111421616-a3ba2f00-8730-11eb-977f-a268ed68705a.png)

# script_3)
 Git으로 관리되고 있는 git-project 라는 프로젝트가 있습니다. 김코딩은 이 레파지토리에 contribute를 하고 싶어요.
 먼저 내 계정으로 해당 Repository를 가지고 오려고 합니다.
 이 때 사용할 수 있는 기능이 Fork 입니다. 포크로 집어서 복사해 온다는 의미라고 생각하시면 됩니다. 우측 상단의 Fork 버튼을 클릭해볼까요?

# slide_4) fork: 다른 계정의 Remote Repository를 내 계정으로 가지고 올 때
![](https://user-images.githubusercontent.com/61301574/110565498-f2e0ec80-8191-11eb-86b4-8e9755b4a0db.jpeg)

# script_4)
 우측 상단의 Fork 버튼을 누르면 다음 화면이 뜨는 것을 확인하실 수 있습니다. 나의 유저네임을 클릭하면 Fork 작업이 완료됩니다.

# slide_5) fork: 다른 계정의 Remote Repository를 내 계정으로 가지고 올 때
![](https://user-images.githubusercontent.com/61301574/110565500-f4121980-8191-11eb-9135-de025c1e77bd.jpeg)

# script_5)
Remote Repository(원격 저장소)란?
GitHub.com 의 내 계정에 Fork해서 들어온 kimcoding / git-project는 나의 Remote Repository (원격 저장소) 입니다.

김코딩이 git-project 를 Fork 를 한 시점부터 이 git-project는 김코딩의 Repository에 복사본으로 저장된 것입니다.
 
git-project 라는 이름의 Repository는 가 완료된 상태는 내 Remote Repository에 해당 Repository가 들어 있는 상태입니다. 이제 Remote에 있는 Repository를 내 로컬 컴퓨터 환경에서 작업할 수 있도록 명령어를 입력해 보겠습니다.

# slide_6) clone: Remote Repository 내 컴퓨터로 가져오기
![](https://user-images.githubusercontent.com/61301574/110565564-07bd8000-8192-11eb-96ab-df9d57647065.jpeg)

```
터미널 화면
Cloning into ‘git-project… \n remote: Enumerating objects: 3, done. \n remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3 Unpacking objects: 100% (3/3), done.
```

# script_6)
 이제 리모트 레파지토리에 있는 내용을 작업하기 위해서는 내 컴퓨터의 로컬 환경으로 복사해오는 작업이 필요합니다. 이 때 사용할 수 있는 명령어가 바로 clone 입니다. git clone 명령어 뒤에 레파지토리 주소를 입력하면 해당 레파지토리를 로컬로 가져와서 작업할 수 있습니다.


# slide_7) status: 내 로컬로 복사해 온 디렉토리의 commit 되기 전까지의 상태 확인
![](https://user-images.githubusercontent.com/61301574/110565605-160b9c00-8192-11eb-9974-8cb87a579670.jpeg)

```
터미널 화면
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   mypage.js
```

# script_7)
 git-project를 포크해서 마이페이지 기능을 구현했다고 가정해봅시다. commit 으로 변경 사항의 저장 기록을 남겨두는 것이 좋을 것 같아요. Commit 을 하기 위해서 먼저 현재 로컬에 변경된 파일들이 어떤 것이 있는지 확인해보려고 합니다. 
git status 명령어를 통해 staging area와 untracked files 목록에 어떤 것들이 있는지 확인할 수 있습니다. 
여러분 중요한 팁이 있는데요. 터미널 창을 꼼꼼히 읽어보면 힌트를 다 주고 있습니다! 현재 어떤 파일이 어떤 상황에 있는지 표시하고 있죠? untracked files 즉 git의 트래킹 되고 있지 않은 파일들 목록에는 mypage라는 파일이 있고 이 파일을 Commit 하기 위해서는 git add 명령어를 통해서 commit 할 수 있다고 나오죠?

mypage.js 파일은 modified, 즉 변경된 상태네요. 그런데, changeds not staged, 즉 staging area에는 들어가지 않았어요.

이 시점에서 우리가 선택할 수 있는 행동을 안내하고 있네요. 첫번째로는 add, add는 커밋할 수 있게 만들어주는 것입니다. 이에 대한 내용은 뒤에서 설명하기로 해요.

또 다른 명령어로는 restore 가 있습니다. 이는 discard changes, 즉 변경사항을 폐기하는 명령어예요. 이처럼 git status 를 통해 어떤 파일이 어떤 상태에 있는지, 그리고 해당 파일에 대해 어떤 행동을 할 수 있는지 알 수 있습니다.

# slide_8) restore: 변경 사항 폐기

슬라이드 작성필요

# script_8)
마이페이지를 열심히 구현해 보았어요! 그러던 중 기존에 있던 코드들을 훑어보니 코드 작성 방식이 나와 달라서 통일성을 해칠 것 같아요. 내가 작업한 코드를 싹 다 밀어버리고 새로 작업 해야할 것 같습니다. 그러니까 처음 Clone 을 받았던 상태로 되돌리는 방법이 있을까요? 이 때 사용할 수 있는 명령어가 바로 아까 터미널에서 확인했던 restore 입니다. 

커밋되지 않은 로컬 변경사항을 폐기할 수 있어요. git restore mypage.js 명령어를 통해 Working directory의 변경사항을 폐기하고 다시 처음으로 clone 받아왔던 상태가 되었습니다.

# slide_9) Add: untracked files를 staging area로 추가해서 Git의 관리 하에 둠
![](https://user-images.githubusercontent.com/61301574/110565637-1f950400-8192-11eb-9f1e-06c6dbf88349.jpeg)

![](https://user-images.githubusercontent.com/61301574/110565702-389db500-8192-11eb-9acd-9f2000e57d73.jpeg)

-> git add 명령어 뒤에 한 칸 띄우고 `.`을 붙이면 staging area의 모든 파일들을 추가할 수 있습니다.

# script_9)
기존 코드의 컨벤션에 맞게 다시 마이페이지 구현을 완료했습니다. 문제없이 잘 작동이 되는 것 같으니 드디어 commit을 할 차례예요. commit 을 하기 위해서는 먼저 Git의 관리 하에 있는 영역으로 파일들을 옮겨주어야 하는데요. 이 영역의 이름은 바로 staging area 입니다. git의 트래킹이 되고 있지 않은 파일들에서 git의 관리 하에 있는 staging area 로 파일들을 추가하는 명령어는 git add <파일이름> 입니다. 여기서는 git add mypage.js 를 입력하면 되겠네요. 

종종 add 해야 할 파일이 너무 많은 경우도 발생하게 될텐데요. 그렇다면 이 파일들을 하나하나 다 적어야 할까요? 아닙니다. git add . 명령어로 모든 파일을 한번에 추가할 수 있습니다.



# slide_10) commit: 수정 작업이 끝난 후 변경 사항을 저장
![](https://user-images.githubusercontent.com/61301574/110565702-389db500-8192-11eb-9acd-9f2000e57d73.jpeg)
￼
![image](https://user-images.githubusercontent.com/61301574/111421648-b2084b00-8730-11eb-9682-0376c307342b.png)

```
터미널 화면
[main 2a4535f] completed 1 files changed, \n 123 insertions(+) create mode 100644 mypage.js
```

# script_10)
 변경 사항을 저장하기 위해서는 commit 을 활용합니다. 어떤 사항이 변경되었는지 간단한 메모를 통해서 버전의 변경 기록들을 관리할 수 있습니다. 위 그림처럼 스냅샷을 찍듯이 변경된 이력을 언제, 누가, 어떻게 변경이 되었는지 저장할 수 있어요.
 이제 mypage.js 파일이 staging area에 올라간 상태이기 때문에 commit이 가능한 파일이 되었어요. commit 메시지를 작성하기 위해서는 -m 옵션을 통해 코멘트를 작성할 수 있습니다. git commit -m ’Add mypage’ 라는 메시지로 commit 을 남겨볼까요?
 참고로 commit 메시지 작성 방법에 대해서는 굉장히 다양한 기준과 컨벤션이 있기 때문에 좋은 commit 메시지를 작성하기 위한 기준을 구글링해 보시는 것을 추천합니다. 
 [슬라이드 삽입](https://chris.beams.io/posts/git-commit/)


# slide_11) Staging area 란?
커밋하기 전에 내용을 기록하는 장소
![image](https://user-images.githubusercontent.com/61301574/111421674-bcc2e000-8730-11eb-934f-3e93f8a95433.png)
- 같은 용도의 물건들을 하나의 무빙 박스에 담기
- 무빙 박스의 내용물에 대한 간단한 라벨링

만약, Git add 명령어로 파일을 staging area에 올려놓고 파일을 또 수정한다면?

```￼
$ git status

On branch masterYour branch is up-to-date with 'origin/master'.Changes to be committed:(use "git reset HEAD ..." to unstage)
new file:   README
modified:   mypage.js
Changes not staged for commit:(use "git add ..." to update what will be committed)(use "git checkout -- ..." to discard changes in working directory)
modified:   mypage.js
```
# script_11)
staging area에 있는 파일만 commit이 가능하다고 하는데 도대체 staging area가 무엇인지 감이 잘 안오시죠? 여기서 잠깐 staging area가 무엇인지 알아볼게요!
예시를 하나 들어보겠습니다. 만약에 여러분이 이사를 가기 위해서 물건을 무빙 박스에 담아야하는 상황을 가정해보겠습니다. 

무빙 박스에는 물건을 넣을 수도 있고 꺼낼 수도 있습니다.
주방, 거실, 침실의 물건들을 같은 상자에 섞으면 나중에 꺼내어 볼 때 불편하겠죠?
같은 용도의 물건들을 한 박스에 넣는 것이 좋을 거예요.
물건들을 박스에 모두 담았다면 밀봉 후 라벨링을 해서 각각의 용도를 적어 주면 나중에 박스를 열어볼 때 편할 거예요.

여기서, 이 무빙 박스가 바로 commit 을 만들 수 있는 staging area이고 박스에 어떤 용도의 물건인지 간단한 코멘트를 적은 라벨링을 해 주는 것이 바로 commit 이라고 이해해 주시면 좋겠습니다.

만약에 git add 명령어로 파일을 staging area에 올려 놓은 상태인데 파일을 또 수정한다면 어떻게 될까요? 이렇게 터미널에 보이는 것처럼 파일이 staged 이면서 modified 인 상태가 됩니다.

즉 git add 명령을 실행하면 Git은 파일을 바로 Staged 상태로 만듭니다. 지금 이 시점에서 커밋을 하면 git commit 명령을 실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 git add 명령을 실행했을 때의 버전이 커밋되지요. 그러니까 git add 명령을 실행한 후에 또 파일을 수정하면 git add 명령을 다시 실행해서 최신 버전을 Staged 상태로 만들어야 합니다.


# slide_12) Reset: 로컬에서 commit 한 내용을 취소할 때

![](https://user-images.githubusercontent.com/61301574/110565718-3e939600-8192-11eb-81ba-1a0f03cb787e.jpeg)

```
터미널 화면
Unstaged changes after reset: \n M   mypage.js
```

- HEAD~3 === HEAD^^^
- HEAD~1 === HEAD^

# script_12)
앗.. 그런데 마이페이지를 새로고침했더니 에러가 발생하네요ㅠㅠ
방금 커밋한 기록을 취소하고 에러를 수정하고 싶어요.
아직 리모트 레파지토리에 업로드 되지 않고 로컬에만 commit 해 놓은 기록이라면 reset 명령어를 통해서 commit 을 취소할 수 있습니다. git reset HEAD^ 이라는 명령어로 가장 최신의 commit 을 취소할 수 있습니다.
 우리는 방금 올린 하나의 commit 만 취소하면 되기 때문에 git reset HEAD^ 명령어를 입력하는 것이 가장 적합하겠죠?
 HEAD~는 연속된 ^의 shortcut 입니다. 예를 들어 HEAD~3은 HEAD^^^와 같습니다. 즉 이 상황에서는 HEAD~1 명령어도 가능합니다.

  추가적으로 hard, soft 옵션도 있는데 reset 에 대해서 더 공부하고 싶으시다면 git reset --hard vs --soft 등의 검색어로 구글링 한 후 실습해 보시는 것을 추천드립니다.

(출처: https://salferrarello.com/git-head-tilde-vs-head-caret/)


# slide_13) push: 로컬에서 변경, commit 된 사항을 Remote Repository에 업로드

![](https://user-images.githubusercontent.com/61301574/110565752-4eab7580-8192-11eb-93c0-0a169ed2d41b.jpeg)

```
Enumerating objects: 1, done. 
Counting objects: 100% (1/1), done. 
Delta compression using up to 1 threads.
Compressing objects: 100% (1/1), done.
Writing objects: 100% (1/1), 212.65 KiB | 10.63 MiB/s, done.
Total 1 (delta 0), reused 0 (delta 0). To https://github.com/codestates/git-project 9ec18c7..6b4395c  main -> main
```

# script_13)
 commit 기록을 남기기를 완료했어요. 이제 이 파일들을 contribute 하기 위해서는 Pull Request 라는 것을 날려주어야 한다고 하는데요. Pull Request를 날리기 위해서는 현재 로컬에 저장되어 있는 commit 기록들을 내 리모트 레파지토리에 업로드해 주어야 git-project Remote Repository에 Pull Request 를 날릴 수가 있습니다.
 내 로컬의 commit 기록들을 리모트 리파지토리로 업로드하기 위해서는 git push origin branch 명령어를 사용할 수 있습니다. git push origin main, git push pair dev 등 git push 뒤에 따라오는 명령어는 상황에 따라 변경할 수 있습니다.

Push를 했더니 GitHub 웹사이트의 레파지토리에 compare & pull request 라는 버튼이 뜨네요.

![](https://user-images.githubusercontent.com/61301574/110565788-61be4580-8192-11eb-9986-85bb1b469d11.png)
![](https://user-images.githubusercontent.com/61301574/110565801-6682f980-8192-11eb-8255-32a2aaf37040.png)
요 버튼을 클릭해서 과제를 완료했다는 Pull Request 날리기를 완료했습니다!

# slide_14) log: 현재까지 commit 된 내역들을 터미널 창에서 확인할 수 있습니다.

![](https://user-images.githubusercontent.com/61301574/110565763-5408c000-8192-11eb-839e-31f35a230ff2.jpeg)


```
commit 6b4395cec5934268a2bb5e41cd81a488891f02fb (HEAD -> main, origin/main, origin/HEAD) 
Author: kimcoding <kimcoding@gmail.com> 
Date:   Tue Feb 16 13:13:56 2021 +0900 
Add mypage
```

# script_14)
남긴 커밋이 잘 기록되었는지 확인해보고 싶어요. git log 라는 명령어를 터미널에 입력해볼까요? 현재까지 commit 된 로그들을 터미널 창에서 확인할 수 있습니다.

여기까지 Remote Repository에 있는 Git 프로젝트를 혼자 작업하는 경우의 workflow 강의였습니다. 감사합니다.